<div class="row">
	<div class="col-md-1">
	</div>
	<div class="col-md-10 center-block text-center">
		<h2><%= title if local_assigns[:title] %></h2>
		<svg id="<%= local_assigns[:domId] ? domId : "chartStacked" %>"></svg>
	</div>
	<div class="col-md-1">
	</div>
</div>

<script type="text/javascript">

	var valField = "<%= local_assigns[:valueField] ? valueField : "debit" %>"
	function transformMulti(data, xCategoryType) {
		// Destination format: [{key:name,values:[{x:xCategory,y:debit},...]}]

		var data_nvd3 = new Array();
		var dataObj = new Object();
		var minQuantum = Number.MAX_SAFE_INTEGER;
		var maxQuantum = 0;

		for( var i = 0 ; i < data.length ; i++ ){

			var key = data[i].name;
			var xCategory = data[i].xCategory;
			var xValue = data[i].xValue;
			var value = data[i][valField];

			minQuantum = Math.min(xValue,minQuantum);
			maxQuantum = Math.max(xValue,maxQuantum);

			if (!(key in dataObj)){
				dataObj[key] = new Object();
				dataObj[key].values = new Array();
			}

			var obj = new Object();
			obj.x = xCategory;
			obj.y = parseFloat(value);
			dataObj[key].values[xValue] = obj;
		}

		for( key in dataObj ){

			// A variable to hold a default year in case xCategory is a date
			var year = null;

			// Fill in any blanks
			for( i = minQuantum ; i <= maxQuantum; i++)
			{
				if( dataObj[key].values[i] == null)
				{
					// Expect an int as fill value but allow for dates
					var fillValue = i;
					if( xCategoryType == typeof Date && !(year === null))
					{
						fillValue = formatDate(new Date(year, 0, i));
						console.log(fillValue);
					}
					dataObj[key].values[i] = {"x":fillValue,"y":0};
				}
				// If xCategory is a date, get a default year
				else if( xCategoryType == typeof Date && year === null )
				{
					var dateString = dataObj[key].values[i].x;
					console.log(dateString);
					var date = new Date(dateString);
					date.setTime(date.getTime() + (12*60*60*1000))
					year = date.getYear() + 1900;
					console.log(year);
				}
			}
			dataObj[key].values.shift();
			var entry = {"key":key,"values":dataObj[key].values};
			data_nvd3.push(entry);
		}
		return data_nvd3;
	}

	function buildMultiBarChart( )
	{
		var domId = "<%= local_assigns[:domId] ? "#" + domId : "#chartStacked" %>";

		var avg = "<%= local_assigns[:average] ? average : nil %>";

		var chartDataIndex = <%= local_assigns[:chartDataIndex] ? chartDataIndex : 0 %>;

		var data = transformMulti(<%= local_assigns[:data] %>, <%= local_assigns[:xCategoryType] %>);

		var height = 550;

		var chart;
		nv.addGraph(function() {
			chart = nv.models.multiBarChart()
				.stacked(true)
				.showControls(false)
				.clipEdge(true)
				.useInteractiveGuideline(true)
				.height(height)
				;

			chart.xAxis
				.showMaxMin(false);

			chart.yAxis
				.tickFormat(d3.format('d'));

			d3.select(domId)
				.datum(data)
				.transition()
				.duration(500)
				.attr("height",height)
				.call(chart);

			nv.utils.windowResize(chart.update);

			return chart;
		});
	}

	buildMultiBarChart();

	function formatDate(date) {
		var d = new Date(date),
			month = '' + (d.getMonth() + 1),
			day = '' + d.getDate(),
			year = d.getFullYear();

		if (month.length < 2)
			month = '0' + month;
		if (day.length < 2)
			day = '0' + day;

		return [year, month, day].join('-');
	}

</script>
